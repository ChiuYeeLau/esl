算法流程：
数据库存储：
    逐句分析，对于每一个句子：
        按照给定语法树字符描述建立语法树
        对于语法树每一个结点寻找代表该结点的单词（某个叶子结点的单词或者无）
        扫描每个结点寻找模式（如V + N）与短语（complete task），以及短语对应的单词位置：
            依次排列孩子结点的关键字得到模式，排列代表单词得到短语以及单词位置
            对于模式和短语去除特定类别的词，如量词、冠词、所有格等
            对于短语去除特定类别的词，如特殊人称代词等
            去除do (not) + V（强调）, must + V（情态动词）, to + V 的结果
            去除have/will/be等 + V（时态）的结果
            被动语态be + V (...)加上be，保留动词被动形式
            形容词修饰查看谓词，如果是be则在模式与短语中添加
            【对于名词短语，依据后缀生成若干个】
        句子、所有模式、短语、单词位置、【用于建立语法树的字符串】构成一条数据
    【寻找频繁出现的项目】

查询处理：
    对短语建立字符串索引，查询关键词
    找到包含所有关键词的短语
    显示关键词，关键词以外的部分用对应模式代替，作为分组信息
    【对于诸如查询user interface，找到包含关键词的短语，将其作为一个结点寻找包含它的短语，比如可能出现propose interface(V + N)，将UI代替模式中的N，分组为V + user interface】
    【对于诸如查询propose user interface，找不到包含所有关键词的短语，则采用前缀的匹配，短语propose interface前缀propose匹配，将V + N的N向下扩展为user interface发现可以匹配，
    此后再将propose user interface作为一个结点寻找包含它的短语，可能出现N + propose + user + interface的结果】
